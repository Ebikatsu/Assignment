\documentclass[a4paper]{jarticle}
\usepackage{comment}
\usepackage{slashbox}
\usepackage{listings,jlisting}
\usepackage[dvipdfmx]{graphicx}
\usepackage[top=20truemm,bottom=20truemm,left=20truemm,right=20truemm]{geometry}
\title{計算機工学実験A課題3レポート}
\author{学生番号 氏名}
\date{2016/11/24}
\lstset{%
	basicstyle={\small},%
	tabsize=8,
	identifierstyle={\small},%
	commentstyle={\small\itshape},%
	keywordstyle={\small\bfseries},%
	ndkeywordstyle={\small},%
	stringstyle={\small\ttfamily},
	frame={tb},
	breaklines=true,
	columns=[1]{fullflexible},%
	numbers=left,%
	xrightmargin=0zw,%
	xleftmargin=3zw,%
	numberstyle={\scriptsize},%
	stepnumber=1,
	numbersep=1zw,%
	lineskip=-0.5ex,%
	keepspaces=true,
	showstringspaces=false
}
\begin{document}
\maketitle
\section{実験の総括的な目的}
\section{各課題の結果}
\subsection{課題1}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題2}
\subsubsection{目的}
ビット毎の演算子$NOT,AND,OR,XOR$を試す論理回路を$Verilog$で記述して、働きを確認する。
\subsubsection{道のり}
まず、$DE2\_TOP.sv$をコピーペーストし、その中で定義されているモジュール$DE2\_TOP$に、ビット毎の演算子$NOT,AND,OR,XOR$を試す論理回路を定義したソースコード\ref{Work2TOP}を作成した。
\lstinputlisting[caption=$DE2\_TOP.sv$,label=Work2TOP]{work2/DE2_TOP.sv}
その後、これをコンパイルしてハードウェアに流し込み、動作を確認した。
\subsubsection{結果}
実際のハードウェア上では、作成した回路は以下の表\ref{Work2NotGateTruthTable},\ref{Work2AndGateTruthTable},\ref{Work2OrGateTruthTable},\ref{Work2XorGateTruthTable}の真理値表のように動作した。
\begin{table}[ht]
	\begin{center}
		\caption{$NOT$回路の真理値表}
		\label{Work2NotGateTruthTable}
		\begin{tabular}{|c|c|c|}
			\hline
			$iSW \left[ 0 \right]$	&$oLEDR \left[ 0 \right]$	&$oLEDR \left[ 1 \right]$\\	\hline\hline
			$0$			&$0$				&$1$\\				\hline
			$1$			&$1$				&$0$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\begin{table}[ht]
	\begin{center}
		\caption{$AND$回路の真理値表}
		\label{Work2AndGateTruthTable}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			$iSW \left[ 1 \right]$	&$iSW \left[ 2 \right]$	&$oLEDR \left[ 2 \right]$	&$oLEDR \left[ 3 \right]$	&$oLEDR \left[ 4 \right]$\\	\hline\hline
			$0$			&$0$			&$0$				&$0$				&$0$\\				\hline
			$0$			&$1$			&$0$				&$1$				&$0$\\				\hline
			$1$			&$0$			&$1$				&$0$				&$0$\\				\hline
			$1$			&$0$			&$1$				&$1$				&$1$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\begin{table}[ht]
	\begin{center}
		\caption{$OR$回路の真理値表}
		\label{Work2OrGateTruthTable}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			$iSW \left[ 3 \right]$	&$iSW \left[ 4 \right]$	&$oLEDR \left[ 5 \right]$	&$oLEDR \left[ 6 \right]$	&$oLEDR \left[ 7 \right]$\\	\hline\hline
			$0$			&$0$			&$0$				&$0$				&$0$\\				\hline
			$0$			&$1$			&$0$				&$1$				&$1$\\				\hline
			$1$			&$0$			&$1$				&$0$				&$1$\\				\hline
			$1$			&$0$			&$1$				&$1$				&$1$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\begin{table}[ht]
	\begin{center}
		\caption{$XOR$回路の真理値表}
		\label{Work2XorGateTruthTable}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			$iSW \left[ 5 \right]$	&$iSW \left[ 6 \right]$	&$oLEDR \left[ 8 \right]$	&$oLEDR \left[ 9 \right]$	&$oLEDR \left[ 10 \right]$\\	\hline\hline
			$0$			&$0$			&$0$				&$0$				&$0$\\				\hline
			$0$			&$1$			&$0$				&$1$				&$1$\\				\hline
			$1$			&$0$			&$1$				&$0$				&$1$\\				\hline
			$1$			&$0$			&$1$				&$1$				&$0$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\subsubsection{考察}
モジュール$DE2\_TOP$に単純な回路を組み込むことによって、$Verilog$の基本的な論理演算子が正常に動作することを確認できた。単にスイッチからの配線を論理ゲートに通してからLEDにつなぐのではなく、スイッチからの配線を別のLEDにそのままつないだものも用意することによって、ハードウェア上で実行したときの結果が分かりやすかった。
\subsection{課題3}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題4}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題5}
\subsubsection{目的}
1ビットの全加算器を実現するモジュール$fulladder$を設計し、トップモジュールに組み込んで試す。
\subsubsection{道のり}
まず、1ビットの全加算器を実現するモジュールを、ソースコード\ref{Work5FullAdder}で定義した。ここでは、単純にassignで配線をつないだモジュール$fulladder$と、課題4で作成した半加算器のモジュール$halfadder$を二つ使用した$fulladderUsingHalfadder$を作成した。
\lstinputlisting[caption=$fulladder.sv$,label=Work5FullAdder]{work5/fulladder.sv}
次に、ソースコード\ref{Work5TOP}にあるように、ソースコード\ref{Work5FullAdder}で定義した二つの全加算器をトップモジュールに組み込み、コンパイルしてハードウェアに流し込み動作を確認した。
\lstinputlisting[caption=$DE2\_TOP.sv$,label=Work5TOP]{work5/DE2_TOP.sv}
\subsubsection{結果}
実際のハードウェア上では、作成した回路は以下の表\ref{Work5FullAdderTruthTable},\ref{Work5FullAdderUsingHalfAdderTruthTable}の真理値表のように動作した。
\begin{table}[ht]
	\begin{center}
		\caption{モジュール$fulladder$の動作の真理値表}
		\label{Work5FullAdderTruthTable}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			$iSW \left[ 0 \right]$	&$iSW \left[ 1 \right]$	&$iSW \left[ 2 \right]$	&$oLEDR \left[ 0 \right]$	&$oLEDR \left[ 1 \right]$\\	\hline\hline
			$a$			&$b$			&$c$			&$co$				&$s$\\				\hline\hline
			$0$			&$0$			&$0$			&$0$				&$0$\\				\hline
			$0$			&$0$			&$1$			&$0$				&$1$\\				\hline
			$0$			&$1$			&$0$			&$0$				&$1$\\				\hline
			$0$			&$1$			&$1$			&$1$				&$0$\\				\hline
			$1$			&$0$			&$0$			&$0$				&$1$\\				\hline
			$1$			&$0$			&$1$			&$1$				&$0$\\				\hline
			$1$			&$1$			&$0$			&$1$				&$0$\\				\hline
			$1$			&$1$			&$1$			&$1$				&$1$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\begin{table}[ht]
	\begin{center}
		\caption{モジュール$fulladderUsingHalfadder$の動作の真理値表}
		\label{Work5FullAdderUsingHalfAdderTruthTable}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			$iSW \left[ 3 \right]$	&$iSW \left[ 4 \right]$	&$iSW \left[ 5 \right]$	&$oLEDR \left[ 2 \right]$	&$oLEDR \left[ 3 \right]$\\	\hline\hline
			$a$			&$b$			&$c$			&$co$				&$s$\\				\hline\hline
			$0$			&$0$			&$0$			&$0$				&$0$\\				\hline
			$0$			&$0$			&$1$			&$0$				&$1$\\				\hline
			$0$			&$1$			&$0$			&$0$				&$1$\\				\hline
			$0$			&$1$			&$1$			&$1$				&$0$\\				\hline
			$1$			&$0$			&$0$			&$0$				&$1$\\				\hline
			$1$			&$0$			&$1$			&$1$				&$0$\\				\hline
			$1$			&$1$			&$0$			&$1$				&$0$\\				\hline
			$1$			&$1$			&$1$			&$1$				&$1$\\				\hline
		\end{tabular}
	\end{center}
\end{table}
\subsubsection{考察}
今回は単純に入力から出力へと配線をつなぐ方法と、半加算器二つを使う方法で同じ動作をする全加算器を作成した。前者の方法は、真理値表通りに作られているので全加算器であることが分かりやすいが、後者の方は、これが全加算器であるといわれなければこれがどんな働きをするのか直感的にはわからないだろうと思った。また、二つの全加算器をトップモジュールに同時に組み込むことで、動作を確認するときに二つが同じ結果を出しているかどうか確認しやすかった。
\subsection{課題6}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題7}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題8}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題9}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題10}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題11}
\subsubsection{目的}
「+」演算子を使った動作モデル化による設計法を用いて、8ビット同士の加算を行うモジュールを定義し、スイッチなどを使って動作確認する。
\subsubsection{道のり}
ソースコード\ref{Work11TOP}のように、「+」演算子を使って$iSW \left[ 7:0 \right]$と$iSW \left[ 15:8 \right]$の和を$oLEDR \left[ 8:0 \right]$につなげ、コンパイルしてハードウェアに流し込み、動作を確認した。
\lstinputlisting[caption=$DE2_TOP.sv$,label=Work11TOP]{work11/DE2_TOP.sv}
\subsubsection{結果}
$oLEDR \left[ 8:0 \right]$は、正しく$iSW \left[ 7:0 \right]$と$iSW \left[ 15:8 \right]$の和を表していた。
\subsubsection{考察}
「+」演算子を使ったモジュールを定義し、動作を確認することで、$Verilog$の「+」演算子は、プログラミング言語の加算と同等の意味を持つことが分かった。また、この演算子の出力は、入力よりも1ビット大きく出力されることが分かった。ハードウェア記述言語でこのような演算子が定義されていることによって、回路の設計がより楽になるだろうと感じた。
\subsection{課題12}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題13}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題14}
\subsubsection{目的}
ソースコード\ref{Work14UnfixedModule}にあるリセットとイネーブルの入力(en)と繰り上がり出力(co)がついた10進カウンタの記述の<考えてね>の部分を補完し完成させて、組み込んで、キーボタンやLED等を使って動作を確認する。
\begin{lstlisting}[caption=count4.sv,label=Work14UnfixedModule]
//count4.svの中身(3/3)
//リセットとイネーブル付き10進カウンタ
module count4dre (
	input logic clk,
	input logic en,		//イネーブル
	input logic clr,	//クリア
	output logic [3:0] q,
	output logic co );	//繰り上がり
	// q == 9 のとき 1
	assign co = (q == 9) & en;
	always_ff @ (posedge clk) begin
		if (clk)	<考えてね>;
		else if (co)	<考えてね>;
		else id (en)	<考えてね>;
	end
endmodule
\end{lstlisting}
\subsubsection{道のり}
まず、ソースコード\ref{Work14UnfixedModule}を修正したソースコード\ref{Work14FixedModule}を用意し、それをソースコード\ref{Work14TOP}のようにトップモジュールに組み込み、コンパイルしてハードウェアに流し込み動作を確認した。
\lstinputlisting[caption=$count4.sv$,label=Work14FixedModule]{work14/count4.sv}
\lstinputlisting[caption=$DE2\_TOP.sv$,label=Work14TOP]{work14/DE2_TOP.sv}
\subsubsection{結果}
実際のハードウェア上では、次の状態遷移表\ref{Work14StateTransitionTable}のように動作した。リセットとイネーブル付き10進カウンタとして正しく動作した。
\begin{table}[ht]
	\begin{center}
		\caption{カウンタの状態遷移表}
		\label{Work14StateTransitionTable}
		\begin{tabular}{|c||c|c|c|c|}
			\hline
			\backslashbox{現状態\\($q$の値)}{$\left(en,clr\right)$}	&$\left(0,0\right)$	&$\left(0,1\right)$	&$\left(1,0\right)$	&$\left(1,1\right)$\\	\hline
			$0$							&$0$			&$0$			&$1$			&$0$\\			\hline
			$1$							&$1$			&$0$			&$2$			&$0$\\			\hline
			$2$							&$2$			&$0$			&$3$			&$0$\\			\hline
			$3$							&$3$			&$0$			&$4$			&$0$\\			\hline
			$4$							&$4$			&$0$			&$5$			&$0$\\			\hline
			$5$							&$5$			&$0$			&$6$			&$0$\\			\hline
			$6$							&$6$			&$0$			&$7$			&$0$\\			\hline
			$7$							&$7$			&$0$			&$8$			&$0$\\			\hline
			$8$							&$8$			&$0$			&$9$			&$0$\\			\hline
			$9$							&$9$			&$0$			&$0$			&$0$\\			\hline
		\end{tabular}
	\end{center}
\end{table}
\subsubsection{考察}
問題文にあるソースコードを修正して、目的のカウンタを作り、正しく動作させることが出来た。ただ、ハードウェア上で実行したときに最初に$clr$を上げた状態でクロックを上げないと出力が初期化されないことに気付かず苦戦した。ソースコードを呼んで、どのような動きになるのか考えながら動作を確認する必要があると感じた。
\subsection{課題15}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題16}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題17}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題18}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題19}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\subsection{課題20}
\subsubsection{目的}
\subsubsection{道のり}
\subsubsection{結果}
\subsubsection{考察}
\section{実験の総括的なまとめや感想}
\end{document}
