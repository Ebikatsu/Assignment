課題B2
・目的
配列の和を求めるC言語のプログラムを読み、それと同等のことをするアセンブリプログラムを作成する。
・C言語版プログラムのリスト
#include<stdio.h>
int array[] = {1,2,4,8,16,32,64,128};
int main(){
  int sum = 0;
  int *a = array;
  int i = 8;
  do{
    int x = *a;
    sum = sum + x;
    a++;
    i--;
  }while(i != 0);
  printf("%d", sum);
  return 0;
}
・完成したプログラムのリスト
	.data
array:	.word 1
	.word 2
	.word 4
	.word 8
	.word 16
	.word 32
	.word 64
	.word 128		#int array[] = {1,2,4,8,16,32,64,128};
	.text
	.align	2
	.globl	main
main:				#int main(){
	move	$a0,$0		#	int sum = 0;
	la	$t0,array	#	int *a = array;
	li	$t1,8		#	int i = 8;
loop:				#	do{
	lw	$t2,0($t0)	#		int x = *a;
	addu	$a0,$a0,$t2	#		sum = sum + x;
	addu	$t0,$t0,4	#		a++;
	subu	$t1,$t1,1	#		i--;
	bne	$t1,$0,loop	#	}while(i != 0);
	li	$v0,1		#	printf("%d", sum);
	syscall
	move	$v0,$0		#	return 0;
	j	$ra		#}
・プログラムの説明
allayラベルで配列を定義している。
mainラベル以下では、
1行目で最終的に配列arrayの和が入るレジスタa0に初期値0を代入する。
2行目でレジスタt0に配列arrayの先頭アドレスを代入する。
3行目で繰り返し処理のカウンターとして使うレジスタt1に8を代入する。
この後ラベルloopに到達し、loopラベル以下では、
1行目で配列の要素を一つずつ代入するためのレジスタt2にメモリ上のt0アドレスにある値を代入する。
2行目でa0にt2を足す。
3行目でt0に4を足し、配列の次の要素を指し示すようにする。
4行目でt1から1を引く。
5行目は繰り返し処理の最後で、t1が0出ない限りラベルloopに戻る。
6行目でsyscallでint型の表示をするためにvoに1を代入する。
7行目でシステムコールでa0の値を表示する。
8行目でプログラムの戻り値0をv0に代入する。
9行目でプログラムの呼び出し側に戻る。
・実行結果、および、その実行結果の正しさの説明
　実行結果は、255と表示されて正常終了した。実際に
1+2+4+8+16+32+64+128=255
である。
・考察
C言語をアセンブリに翻訳する形でプログラムを作成することで、大きなプログラムを直接アセンブリで書くよりも、まずC言語で書いてみて、それを一行ずつアセンブリに翻訳していくという方法が時間的にも効率的で、バグも発生しにくいことを実感することが出来た。
