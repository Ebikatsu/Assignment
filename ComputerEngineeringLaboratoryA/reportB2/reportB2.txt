・C言語版プログラムのリスト
#include<stdio.h>
int array[] = {1,2,4,8,16,32,64,128};
int main(){
  int sum = 0;
  int *a = array;
  int i = 8;
  do{
    int x = *a;
    sum = sum + x;
    a++;
    i--;
  }while(i != 0);
  printf("%d", sum);
  return 0;
}
・完成したプログラムのリスト
	.data
array:	.word 1
	.word 2
	.word 4
	.word 8
	.word 16
	.word 32
	.word 64
	.word 128		#int array[] = {1,2,4,8,16,32,64,128};
	.text
	.align	2
	.globl	main
main:				#int main(){
	move	$a0,$0		#	int sum = 0;
	la	$t0,array	#	int *a = array;
	li	$t1,8		#	int i = 8;
loop:				#	do{
	lw	$t2,0($t0)	#		int x = *a;
	addu	$a0,$a0,$t2	#		sum = sum + x;
	addu	$t0,$t0,4	#		a++;
	subu	$t1,$t1,1	#		i--;
	bne	$t1,$0,loop	#	}while(i != 0);
	li	$v0,1		#	printf("%d", sum);
	syscall
	move	$v0,$0		#	return 0;
	j	$ra		#}
・プログラムの説明
allayラベルで配列を定義している。
mainラベル以下では、
1行目で最終的に配列arrayの和が入るレジスタa0に初期値0を代入する。
2行目でレジスタt0に配列arrayの先頭アドレスを代入する。
3行目で繰り返し処理のカウンターとして使うレジスタt1に8を代入する。
この後ラベルloopに到達し、loopラベル以下では、
1行目で配列の要素を一つずつ代入するためのレジスタt2にメモリ上のt0アドレスにある値を代入する。
2行目でa0にt2を足す。
3行目でt0に4を足し、配列の次の要素を指し示すようにする。
4行目でt1から1を引く。
5行目は繰り返し処理の最後で、t1が0出ない限りラベルloopに戻る。
6行目でsyscallでint型の表示をするためにvoに1を代入する。
7行目でシステムコールでa0の値を表示する。
8行目でプログラムの戻り値0をv0に代入する。
9行目でプログラムの呼び出し側に戻る。
・実行結果、および、その実行結果の正しさの説明
　実行結果は、255と表示されて正常終了した。実際に
1+2+4+8+16+32+64+128=255
である。